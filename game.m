function varargout = game(varargin)
    gui_Singleton = 1;
    gui_State = struct('gui_Name',       mfilename, ...
                       'gui_Singleton',  gui_Singleton, ...
                       'gui_OpeningFcn', @game_OpeningFcn, ...
                       'gui_OutputFcn',  @game_OutputFcn, ...
                       'gui_LayoutFcn',  [] , ...
                       'gui_Callback',   []);
    if nargin && ischar(varargin{1})
        gui_State.gui_Callback = str2func(varargin{1});
    end

    if nargout
        [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
    else
        gui_mainfcn(gui_State, varargin{:});
    end

function game_OpeningFcn(hObject, eventdata, handles, varargin)
    handles.output = hObject;
    init 
    set(handles.figure1,'CurrentAxes',handles.axes1);
    imageData = imread('ChessBoard.jpg');
    imageHandle = image(imageData);
    hold on;
    set(gca,'xtick',[],'ytick',[]);
    axis square;
    set(gcf,'CurrentAxes',handles.chessPaintBoard);
    set(handles.chessPaintBoard,'xtick',[],'ytick',[]);
    set(handles.chessPaintBoard,'color','none');
    axis square;

    % bg image
    pic_bg = imread('gamebg.png');
    image(pic_bg,'parent',handles.axes_gmbg)
    set(handles.axes_gmbg,'xtick',[],'ytick',[]);

    %--- four image button and set button----
    picBP = imread('back_page.png');
    BPImhandles = image(picBP,'parent',handles.axesBackp);
    set(handles.axesBackp,'xtick',[],'ytick',[]);
    set(BPImhandles, 'ButtonDownFcn', @backPage_ClickFcn);
    
    picPass = imread('pass.png');
    passImhandles = image(picPass,'parent',handles.axesPass);
    set(handles.axesPass,'xtick',[],'ytick',[]);
    set(passImhandles, 'ButtonDownFcn', @pass_ClickFcn);

    picLog = imread('Save.png');
    logImhandles = image(picLog,'parent',handles.axesLog);
    set(handles.axesLog,'xtick',[],'ytick',[]);
    set(logImhandles, 'ButtonDownFcn', @log_ClickFcn);

    picUndo = imread('regret.png');
    undoImhandles = image(picUndo,'parent',handles.axesUndo);
    set(handles.axesUndo,'xtick',[],'ytick',[]);
    set(undoImhandles, 'ButtonDownFcn', @undo_ClickFcn);
    %------------------

    handles.chessBoard = imageHandle;
    guidata(hObject, handles);

    if nargin>3
        continueGame(varargin,gca);
    end


function varargout = game_OutputFcn(hObject, eventdata, handles) 
varargout{1} = handles.output;

    
function chessPaintBoard_ButtonDownFcn(hObject, eventdata, handles)
    cursorPoint = get(handles.chessPaintBoard, 'CurrentPoint');
    curX = cursorPoint(1,1);
    curY = cursorPoint(1,2);
    [x,y] = coordinateConvert(curX,curY);
    if x>0 && y>0
        curPlayer = getCurrentPlayer();
        if setChess([x,y],curPlayer)==false
            msgbox('This position is not allowed to set chess!','modal');
            return;
        end
        setLastStepChess([x,y]);
        resetEndChecker();
        writeToHistory([x,y,curPlayer]);
        takenChess = takeChess(x,y);
        if ~isempty(takenChess)
            unsetChess(takenChess);
        end
        updateChessBoard(handles.chessPaintBoard);
        writeToLogField(handles.chessLogField);
        nextTurn();
    end

    %=======game button image=====
function backPage_ClickFcn(hObject, eventdata)
    handles = guidata(hObject);
    close(gcf)
    startpage
    
function pass_ClickFcn(hObject, eventdata)

    handles = guidata(hObject);
    global tmpLogName;
    pass();
    if isGameFinished()
        msgbox('Both player pass in succession. The game is finished.','modal');
        writeSgfForGnuGo();
        if strcmp(computer('arch'),'glnxa64') %linux
            system(sprintf('./gnugo-linux/gnugo --score aftermath -l %s > score',tmpLogName));
        elseif strcmp(computer('arch'),'win32') || strcmp(computer('arch'),'win64') %windows
            system(sprintf('gnugo-windows\\gnugo.exe --score aftermath -l %s > score',tmpLogName));
        end
        fileID = fopen('score','r');
        if fileID<0
            disp('The score file generated by gnugo not found.');
        end
        tline = fgets(fileID);
        wordParts = strsplit(tline);
        % White wins by 100.5 points
        winKomi = str2double(wordParts(4));
        msgbox(sprintf('%s wins by %f points.',tline(1),winKomi));
        fclose(fileID);
        delete(tmpLogName);
    end

function log_ClickFcn(hObject, eventdata)
    writeHistoryToFileSgf();

function undo_ClickFcn(hObject, eventdata)
    handles = guidata(hObject);
    if undo()~=false
        updateChessBoard(handles.chessPaintBoard);
    end

%======================================



function chessLogField_Callback(hObject, eventdata, handles)
% hObject    handle to chessLogField (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of chessLogField as text
%        str2double(get(hObject,'String')) returns contents of chessLogField as a double


% --- Executes during object creation, after setting all properties.
function chessLogField_CreateFcn(hObject, eventdata, handles)
% hObject    handle to chessLogField (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end
